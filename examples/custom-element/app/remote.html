<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="https://fav.farm/üõ∞Ô∏è" />
    <title>Custom element (remote) ‚Ä¢ Remote DOM</title>
  </head>

  <body>
    <div id="root">
      <ui-button primary>Clicked 5 times</ui-button>
      <custom-foo primary>Clicked 0 times</custom-foo>
    </div>

    <script>
      const myCustomElements = {};
    </script>

    <script type="module">
      import {RemoteElement} from '@remote-dom/core/elements';

      const originalCustomElementDefine =
        customElements.define.bind(customElements);
      customElements.define = (name, constructor) => {
        if (name.indexOf('custom-') === 0) {
          class CustomElement extends RemoteElement {
            static get remoteProperties() {
              return constructor.remoteProperties;
            }
          }
          myCustomElements[name] = constructor;
          originalCustomElementDefine(name, CustomElement);
          originalCustomElementDefine(`internal-${name}`, constructor);
        } else {
          originalCustomElementDefine(name, constructor);
        }
      };

      class CustomFoo extends HTMLElement {
        static get remoteProperties() {
          return {
            primary: {type: Boolean},
            onClick: {event: true},
          };
        }

        static get observedAttributes() {
          return ['primary'];
        }

        onClick;

        connectedCallback() {
          const primary = this.hasAttribute('primary') ?? false;

          const root = this.attachShadow({mode: 'open'});

          // We render a <slot> where we want the element‚Äôs children to go.
          root.innerHTML = `
            <style>
              .Button {
                appearance: none;
                font-size: 1rem;
                padding: 0.5rem 1rem;
                background: transparent;
                border: 1px solid gray;
                border-radius: 0.5rem;
              }

              .Button--primary {
                background: blue;
                color: white;
              }
            </style>
            <button class="Button"><slot></slot></button>
          `;

          if (primary) {
            root.querySelector('.Button').classList.add('Button--primary');
          }

          // We‚Äôll listen for clicks on our button, and call the remote `onClick`
          // property when it happens.
          root.querySelector('button').addEventListener('click', () => {
            this.onClick?.();
          });
        }

        attributeChangedCallback(name, oldValue, newValue) {
          if (name === 'primary') {
            const button = this.shadowRoot?.querySelector('.Button');

            if (button == null) return;

            if (newValue == null) {
              button.classList.remove('Button--primary');
            } else {
              button.classList.add('Button--primary');
            }
          }
        }

        // Remote DOM will automatically call methods on a custom element to satisfy
        // remote method calls.
        focus() {
          this.shadowRoot.querySelector('button').focus();
        }
      }

      customElements.define('custom-foo', CustomFoo);

      // We need to define our `ui-button` element so it can be synchronized
      // with the host environment.
      //
      // For full details on defining remote elements, see the documentation
      // for `@remote-dom/core/elements`:
      // https://github.com/Shopify/remote-dom/tree/main/packages/core#elements
      class UIButton extends RemoteElement {
        static get remoteProperties() {
          return {
            // A boolean property can be set either by setting the attribute to a non-empty
            // value, or by setting the property to `true`.
            primary: {type: Boolean},
            // Remote DOM will convert the `click` event into an `onClick` property that
            // is communicated to the host.
            onClick: {event: true},
          };
        }
      }

      customElements.define('ui-button', UIButton);
    </script>

    <script type="module">
      // To make this example dynamic, we‚Äôll add an event listener to the button
      // that updates the button‚Äôs text content and removes the `primary` attribute
      let count = 0;
      const button = document.querySelector('ui-button');

      button.addEventListener('click', () => {
        count += 1;

        button.textContent = `Clicked ${count} ${
          count === 1 ? 'time' : 'times'
        }`;

        if (count === 5) {
          button.removeAttribute('primary');
        }
      });
    </script>

    <script type="module">
      import {RemoteMutationObserver} from '@remote-dom/core/elements';
      import {retain, createThreadFromInsideIframe} from '@quilted/threads';

      const root = document.querySelector('#root');

      // We use the `@quilted/threads` library to create a ‚Äúthread‚Äù for our iframe,
      // which lets us communicate over `postMessage` without having to worry about
      // most of its complexities.
      //
      // This block exposes the `render` method that was used by the host application,
      // in `index.html`. We receive the `RemoteConnection` object, and start synchronizing
      // changes to the `<div id="root">` element that contains our UI.
      createThreadFromInsideIframe({
        expose: {
          defineCustomElement(callback) {
            Object.keys(myCustomElements).forEach((name) => {
              const {remoteProperties} = myCustomElements[name];
              callback(name, remoteProperties, (connection) => {
                retain(connection);
                const observer = new RemoteMutationObserver(connection);
                // const subRoot = document.createElement(`internal-${name}`);
                const div = document.createElement('div');
                div.appendChild(document.createElement('span'));
                document.appendChild(div);
                observer.observe(subRoot);
              });
            });
          },
          render(connection) {
            // `connection` contains functions that were transferred over `postMessage`.
            // In order to call these functions later, we need to mark them as used in
            // order to prevent garbage collection.
            retain(connection);

            // We use the `RemoteMutationObserver` class, which extends the native DOM
            // `MutationObserver`, to send any changes to a tree of DOM elements over
            // a `RemoteConnection`.
            const observer = new RemoteMutationObserver(connection);
            observer.observe(root);
          },
        },
      });
    </script>
  </body>
</html>
